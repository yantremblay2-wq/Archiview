<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number Grid Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
        }
        .game-container {
            background-color: #ffffff;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            width: 100%;
            max-width: 600px;
            text-align: center;
            position: relative;
            box-sizing: border-box;
            margin: 0 auto;
        }
        .game-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin: 1.5rem auto;
            border: 2px solid #cbd5e0;
            border-radius: 12px;
            padding: 8px;
            width: calc(100% - 2rem);
            max-width: 450px;
            box-sizing: border-box;
        }
        .grid-cell {
            aspect-ratio: 1 / 1;
            position: relative;
            background-color: #f7fafc;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            user-select: none;
            /* Force minimum height to prevent collapse */
            min-height: 60px;
        }
        .grid-cell:hover {
            background-color: #e2e8f0;
        }
        
        /* --- CLS FIX: Fixed Content Container --- */
        .grid-cell-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 700;
            line-height: 1;
        }

        /* Use opacity instead of visibility to maintain layout */
        .grid-cell-content.transparent-content {
            opacity: 0;
            pointer-events: none;
        }
        /* --- END CLS FIX --- */

        /* Tile appearance on the grid */
        .occupied.player-1 {
            background-color: #f7fafc;
            color: #2d3748;
            border: 2px solid #63b3ed; 
        }
        .occupied.player-2 {
            background-color: #2d3748;
            color: #ffffff;
            border: 2px solid #a0aec0;
        }
        .player-info {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: nowrap;
            align-items: stretch;
        }
        .player-card {
            padding: 1rem;
            border-radius: 12px;
            flex: 0 1 auto;
            min-width: 150px;
            max-width: 200px;
        }
        
        .player-card p {
            white-space: nowrap;
            font-size: 0.9rem;
        }
        
        #player-1-card {
            background-color: #ffffff;
            color: #2d3748;
            border: 2px solid #2d3748;
        }
        
        #player-2-card {
            background-color: #2d3748;
            color: #ffffff;
            border: 2px solid #2d3748;
        }
        
        #total-score-card {
            background-color: #e2e8f0;
            padding: 0.5rem 1rem;
            border-radius: 12px;
            min-width: 150px;
            max-width: 200px;
            margin: 1rem auto 0.5rem auto;
        }
        
        .number-btn {
            border-radius: 8px;
            font-size: 1.25rem;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s ease, opacity 0.2s ease;
            box-shadow: none;
            min-width: 50px;
            padding: 0.75rem 0.5rem;
            line-height: 1;
        }
        .number-btn:hover:not([disabled]) {
            transform: scale(1.05);
        }
        .number-btn[disabled] {
            opacity: 0.4;
            cursor: not-allowed;
            transform: scale(1);
        }

        /* --- POPUP STYLES --- */
        .popup {
            position: fixed;
            background-color: #f0f4f8; 
            padding: 0.5rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
            flex-direction: column; 
            gap: 0;
        }
        .popup-visible {
            display: flex;
        }
        .popup-columns {
            display: flex;
            gap: 0.5rem;
        }
        .popup-column {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.25rem;
            border-radius: 8px;
        }
        
        .popup-remove-btn {
            background-color: #ef4444;
            color: white;
            border: 3px solid #dc2626;
            margin-top: 0.5rem;
        }
        
        /* Style for the White column (Light Grey Tile, Black Number) */
        .popup-btn-p1 {
            background-color: #f7fafc;
            color: #2d3748;
            border: 3px solid #2d3748;
        }
        /* Style for the Black column (Black Tile, White Number) */
        .popup-btn-p2 {
            background-color: #2d3748;
            color: white;
            border: 3px solid #2d3748;
        }
        /* --- END POPUP STYLES --- */

        
        .control-btn {
            background-color: #e2e8f0;
            color: #4a5568;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 1rem;
        }
        #timer-display {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.25rem;
            font-weight: 700;
            color: #4a5568;
            z-index: 10;
        }
        
        @media (max-width: 640px) {
            #timer-display {
                position: static;
                text-align: center;
                margin-bottom: 1rem;
            }
            
            .game-container {
                padding: 1rem;
            }
            
            .game-grid {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="timer-display">00:00</div>
        <!-- Status bar removed -->

        <div class="player-info">
            <div id="player-1-card" class="player-card">
                <p>1s: <span id="p1-1s"></span> | 2s: <span id="p1-2s"></span> | 3s: <span id="p1-3s"></span></p>
                <p class="mt-1 font-bold">Score: <span id="p1-score">0</span></p>
            </div>
            <div id="player-2-card" class="player-card">
                <p>1s: <span id="p2-1s"></span> | 2s: <span id="p2-2s"></span> | 3s: <span id="p2-3s"></span></p>
                <p class="mt-1 font-bold">Score: <span id="p2-score">0</span></p>
            </div>
        </div>

        <div id="number-popup" class="popup">
            <div class="popup-columns">
                <!-- White Column (Light Grey Tile, Black Number) -->
                <div class="popup-column">
                    <button class="number-btn popup-btn-p1" data-player="1" data-value="3">3</button>
                    <button class="number-btn popup-btn-p1" data-player="1" data-value="2">2</button>
                    <button class="number-btn popup-btn-p1" data-player="1" data-value="1">1</button>
                </div>
                <!-- Black Column (Black Tile, White Number) -->
                <div class="popup-column">
                    <button class="number-btn popup-btn-p2" data-player="2" data-value="3">3</button>
                    <button class="number-btn popup-btn-p2" data-player="2" data-value="2">2</button>
                    <button class="number-btn popup-btn-p2" data-player="2" data-value="1">1</button>
                </div>
            </div>
            <button id="remove-btn" class="number-btn popup-remove-btn">Remove</button>
        </div>

        <div id="game-grid" class="game-grid"></div>

        <div id="total-score-card">
            <h3 id="total-score-title" class="text-sm font-bold">Total Score</h3>
            <p id="total-score" class="font-bold text-xl">0</p>
        </div>

        <div class="flex flex-col items-center mt-4">
            <div class="flex justify-center gap-4 w-full">
                <button id="undo-btn" class="control-btn">Undo</button>
                <button id="reset-btn" class="control-btn">Reset</button>
                <button id="toggle-size-btn" class="control-btn">Switch to 7x7</button>
            </div>
        </div>
    </div>

    <script>
        // Game state variables
        let selectedCellIndex = null;
        let gridSize = 5;
        let board = Array(gridSize * gridSize).fill(null);
        let history = []; // Stores state BEFORE each successful move

        let initialPlayerCounts = { '1': 4, '2': 4, '3': 4 };

        let players = {
            1: { numbers: JSON.parse(JSON.stringify(initialPlayerCounts)), score: 0 },
            2: { numbers: JSON.parse(JSON.stringify(initialPlayerCounts)), score: 0 }
        };

        const playerNames = { 1: 'White', 2: 'Black' };

        // Timer variables
        let timerInterval = null;
        let startTime = null;
        let isFirstMove = true;

        // DOM elements
        const gridEl = document.getElementById('game-grid');
        const numberPopup = document.getElementById('number-popup');
        const popupButtons = numberPopup.querySelectorAll('.number-btn:not(#remove-btn)');
        const removeBtn = document.getElementById('remove-btn');
        const undoBtn = document.getElementById('undo-btn');
        const resetBtn = document.getElementById('reset-btn');
        const toggleSizeBtn = document.getElementById('toggle-size-btn');
        const timerDisplay = document.getElementById('timer-display');
        const totalScoreTitleEl = document.getElementById('total-score-title'); 

        // Initial rendering and setup
        window.onload = function() {
            resetGame(false);

            timerDisplay.textContent = '00:00';

            popupButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const value = button.dataset.value;
                    const player = parseInt(button.dataset.player);
                    if (selectedCellIndex !== null && !button.disabled) {
                        placeNumber(player, value, selectedCellIndex);
                        hideNumberPopup();
                    }
                });
            });

            removeBtn.addEventListener('click', () => {
                if (selectedCellIndex !== null) {
                    removeNumber(selectedCellIndex);
                    hideNumberPopup();
                }
            });

            undoBtn.addEventListener('click', undo);
            resetBtn.addEventListener('click', () => resetGame(true));
            toggleSizeBtn.addEventListener('click', toggleGridSize);

            document.addEventListener('click', (event) => {
                // Hide popup if click is outside the popup AND outside the grid cells
                if (!numberPopup.contains(event.target) && !event.target.closest('.grid-cell')) {
                    hideNumberPopup();
                }
            });
        };

        // Functions
        function renderGrid() {
            gridEl.innerHTML = '';
            gridEl.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            
            // Adjust max-width based on grid size
            if (gridSize === 7) {
                gridEl.style.maxWidth = '550px';
            } else {
                gridEl.style.maxWidth = '450px';
            }

            for (let i = 0; i < gridSize * gridSize; i++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.index = i;

                const contentDiv = document.createElement('div');
                contentDiv.classList.add('grid-cell-content');
                
                // ALWAYS set text content to prevent layout shifts
                // Use the actual value if occupied, otherwise use '3' as placeholder
                if (board[i] !== null) {
                    contentDiv.textContent = board[i].value;
                    cell.classList.add('occupied', `player-${board[i].player}`);
                    contentDiv.classList.remove('transparent-content');
                } else {
                    contentDiv.textContent = '3'; // Always render '3' as placeholder
                    cell.classList.remove('occupied', 'player-1', 'player-2');
                    contentDiv.classList.add('transparent-content');
                }
                
                cell.appendChild(contentDiv);
                cell.addEventListener('click', showNumberPopup);
                gridEl.appendChild(cell);
            }
        }

        function startTimer() {
            stopTimer(); 
            startTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 1000);
            updateTimerDisplay();
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function updateTimerDisplay() {
            if (startTime) {
                const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;
                const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                timerDisplay.textContent = formattedTime;
            }
        }

        function showNumberPopup(event) {
            const cell = event.target.closest('.grid-cell');
            event.stopPropagation();
            selectedCellIndex = parseInt(cell.dataset.index);
            const currentCellState = board[selectedCellIndex];

            // Position Popup
            numberPopup.classList.add('popup-visible');

            const cellRect = cell.getBoundingClientRect();
            const popupRect = numberPopup.getBoundingClientRect();

            let popupLeft = cellRect.left + cellRect.width / 2 - popupRect.width / 2;
            let popupTop = cellRect.top + cellRect.height / 2 - popupRect.height / 2;

            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Adjust to keep fully visible
            if (popupLeft < 5) popupLeft = 5;
            else if (popupLeft + popupRect.width > viewportWidth - 5) popupLeft = viewportWidth - popupRect.width - 5;

            if (popupTop < 5) popupTop = 5;
            else if (popupTop + popupRect.height > viewportHeight - 5) popupTop = viewportHeight - popupRect.height - 5;

            numberPopup.style.left = `${popupLeft}px`;
            numberPopup.style.top = `${popupTop}px`;

            // Show/hide Remove button based on cell state
            if (currentCellState !== null) {
                removeBtn.style.display = 'block';
            } else {
                removeBtn.style.display = 'none';
            }

            // Enable/Disable Buttons based on inventory
            popupButtons.forEach(button => {
                const newValue = button.dataset.value;
                const newPlayer = parseInt(button.dataset.player);

                let count = players[newPlayer].numbers[newValue];

                // If the selected move is replacing the existing piece with the SAME piece,
                // the inventory count will temporarily be +1 higher than shown.
                const isSamePiece = currentCellState && currentCellState.player === newPlayer && currentCellState.value == newValue;

                if (count > 0 || isSamePiece) {
                     button.disabled = false;
                } else {
                     button.disabled = true;
                }
            });
        }

        function hideNumberPopup() {
            numberPopup.classList.remove('popup-visible');
            selectedCellIndex = null;
        }

        function placeNumber(newPlayer, newValue, index) {
            if (isFirstMove) {
                startTimer();
                isFirstMove = false;
            }

            const currentCellState = board[index];
            const newValueStr = newValue.toString();

            // Check if placing the exact same piece (no change in state or inventory needed)
            const isSamePiece = currentCellState && currentCellState.player === newPlayer && currentCellState.value == newValueStr;
            if (isSamePiece) {
                return;
            }

            // --- Inventory Management Start ---

            // 1. Record history (State BEFORE the move)
            history.push({
                board: JSON.parse(JSON.stringify(board)),
                players: JSON.parse(JSON.stringify(players)),
            });

            // 2. REFUND the old piece (if editing)
            if (currentCellState !== null) {
                const oldPlayer = currentCellState.player;
                const oldValue = currentCellState.value.toString();
                players[oldPlayer].numbers[oldValue]++;
            }

            // 3. DEDUCT the new piece
            players[newPlayer].numbers[newValueStr]--;

            // 4. CHECK INVENTORY for negative count (invalid move)
            if (players[newPlayer].numbers[newValueStr] >= 0) {
                // Placement is valid!

                // 5. Update the board
                board[index] = { value: parseInt(newValueStr), player: newPlayer };

                calculateScores();
                selectedCellIndex = null;

                renderGrid();
                updateUI();
                checkGameOver();

            } else {
                // Invalid placement (ran out of numbers)

                // 6. REVERSE the deduction and refund to restore state
                players[newPlayer].numbers[newValueStr]++; // Reverse deduction
                if (currentCellState !== null) {
                    const oldPlayer = currentCellState.player;
                    const oldValue = currentCellState.value.toString();
                    players[oldPlayer].numbers[oldValue]--; // Reverse refund
                }

                // Remove the last (failed) history entry
                history.pop();

                // Re-render and show message with inventory counts fixed
                renderGrid();
                updateUI();
            }
        }

        function removeNumber(index) {
            const currentCellState = board[index];
            
            // Only remove if cell is occupied
            if (currentCellState === null) {
                return;
            }

            // Record history (State BEFORE the move)
            history.push({
                board: JSON.parse(JSON.stringify(board)),
                players: JSON.parse(JSON.stringify(players)),
            });

            // REFUND the removed piece
            const oldPlayer = currentCellState.player;
            const oldValue = currentCellState.value.toString();
            players[oldPlayer].numbers[oldValue]++;

            // Clear the cell
            board[index] = null;

            calculateScores();
            selectedCellIndex = null;

            renderGrid();
            updateUI();
            
            // Clear any game over status
            totalScoreTitleEl.textContent = 'Total Score';
        }

        function updateUI() {
            document.getElementById(`p1-1s`).textContent = players[1].numbers['1'];
            document.getElementById(`p1-2s`).textContent = players[1].numbers['2'];
            document.getElementById(`p1-3s`).textContent = players[1].numbers['3'];
            document.getElementById(`p2-1s`).textContent = players[2].numbers['1'];
            document.getElementById(`p2-2s`).textContent = players[2].numbers['2'];
            document.getElementById(`p2-3s`).textContent = players[2].numbers['3'];
            document.getElementById(`p1-score`).textContent = players[1].score;
            document.getElementById(`p2-score`).textContent = players[2].score;
            document.getElementById('total-score').textContent = players[1].score + players[2].score;
        }

        function resetGame(showMsg = true) {
            selectedCellIndex = null;
            board = Array(gridSize * gridSize).fill(null);

            // Adjusted initial counts based on grid size
            if (gridSize === 7) {
                initialPlayerCounts = { '1': 8, '2': 8, '3': 8 };
            } else {
                initialPlayerCounts = { '1': 4, '2': 4, '3': 4 };
            }

            players = {
                1: { numbers: JSON.parse(JSON.stringify(initialPlayerCounts)), score: 0 },
                2: { numbers: JSON.parse(JSON.stringify(initialPlayerCounts)), score: 0 }
            };

            // Reset history to contain only the initial state
            history = [];
            history.push({
                board: JSON.parse(JSON.stringify(board)),
                players: JSON.parse(JSON.stringify(players)),
            });

            renderGrid();
            updateUI();
            stopTimer();
            isFirstMove = true;
            timerDisplay.textContent = '00:00';
            
            // Reset the Total Score title
            totalScoreTitleEl.textContent = 'Total Score';
        }

        function toggleGridSize() {
            gridSize = (gridSize === 5) ? 7 : 5;
            toggleSizeBtn.textContent = `Switch to ${gridSize === 5 ? '7x7' : '5x5'}`;
            resetGame();
        }

        function calculateScores() {
            players[1].score = 0;
            players[2].score = 0;

            for (let i = 0; i < gridSize * gridSize; i++) {
                const cell = board[i];
                if (cell !== null) {
                    const row = Math.floor(i / gridSize);
                    const col = i % gridSize;
                    let tileScore = 0;

                    const neighbors = [
                        { r: row - 1, c: col },
                        { r: row + 1, c: col },
                        { r: row, c: col - 1 },
                        { r: row, c: col + 1 }
                    ];

                    neighbors.forEach(neighbor => {
                        if (neighbor.r >= 0 && neighbor.r < gridSize && neighbor.c >= 0 && neighbor.c < gridSize) {
                            const neighborIndex = neighbor.r * gridSize + neighbor.c;
                            const neighborValue = board[neighborIndex] ? board[neighborIndex].value : 0;
                            tileScore += Math.max(0, cell.value - neighborValue);
                        } else {
                            // Border cell penalty is calculated against a value of 0
                            tileScore += Math.max(0, cell.value - 0);
                        }
                    });

                    players[cell.player].score += tileScore;
                }
            }
        }

        function undo() {
            if (history.length > 1) {
                // Pop the current state (the one created by the last valid move)
                history.pop();

                // Load the previous state
                const lastState = history[history.length - 1];

                board = JSON.parse(JSON.stringify(lastState.board));
                players = JSON.parse(JSON.stringify(lastState.players));

                calculateScores();
                renderGrid();
                updateUI();
                
                if (history.length === 1) {
                    stopTimer();
                    isFirstMove = true;
                    timerDisplay.textContent = '00:00';
                }
                
                // Clear any game over status on the total score card
                totalScoreTitleEl.textContent = 'Total Score';

            } else if (history.length === 1) {
                // If only the initial state is left, reset the game fully
                resetGame(false);
            }
        }

        function checkGameOver() {
            const occupiedCells = board.filter(cell => cell !== null).length;
            const totalCells = gridSize * gridSize;

            // Game over when there is one tile empty
            if (occupiedCells === totalCells - 1) {
                stopTimer();
                const p1Score = players[1].score;
                const p2Score = players[2].score;
                const finalTime = timerDisplay.textContent;
                let winnerMessage = "";

                if (p1Score > p2Score) {
                    winnerMessage = `Game Over! White wins (${p1Score} vs ${p2Score}). Time: ${finalTime}.`;
                } else if (p2Score > p1Score) {
                    winnerMessage = `Game Over! Black wins (${p2Score} vs ${p1Score}). Time: ${finalTime}.`;
                } else {
                    winnerMessage = `Game Over! It's a tie (${p1Score} each). Time: ${finalTime}.`;
                }

                // Display the game over message in the Total Score Card title
                totalScoreTitleEl.textContent = winnerMessage;
            }
        }

    </script>
</body>
</html>
