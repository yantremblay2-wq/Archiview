<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number Grid Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            padding: 1rem;
        }
        .game-container {
            background-color: #ffffff;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            width: 100%;
            max-width: 600px;
            text-align: center;
        }
        .game-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin: 1.5rem auto;
            border: 2px solid #cbd5e0;
            border-radius: 12px;
            padding: 8px;
        }
        .grid-cell {
            width: 100%;
            padding-top: 100%; /* This is the key to creating a perfect square aspect ratio */
            position: relative;
            background-color: #f7fafc;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        /* New class for centering content within the square */
        .grid-cell-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: 700;
        }
        .grid-cell:hover:not(.occupied):not(.center-cell) {
            background-color: #e2e8f0;
        }
        .occupied {
            cursor: not-allowed;
        }
        .occupied.player-1 {
            background-color: #f7fafc;
            color: #2d3748;
        }
        .occupied.player-2 {
            background-color: #2d3748;
            color: #ffffff;
        }
        .center-cell {
            background-color: #e2e8f0;
            cursor: not-allowed;
        }
        .player-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        .player-card {
            background-color: #e2e8f0;
            padding: 1rem;
            border-radius: 12px;
            width: 45%;
            min-width: 150px;
            margin-top: 1rem;
        }
        .player-card.active {
            box-shadow: 0 0 0 3px #63b3ed;
            background-color: #ebf8ff;
        }
        .number-selector {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .number-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s ease, background-color 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-color: #63b3ed;
            color: white;
        }
        .number-btn.selected {
            background-color: #4299e1;
            transform: scale(1.1);
        }
        .number-btn:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
        }
        #message-box {
            background-color: #fff;
            padding: 1rem;
            border-radius: 12px;
            text-align: center;
            font-weight: 700;
            margin-top: 1rem;
        }
        #undo-btn {
            background-color: #e2e8f0;
            color: #4a5568;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <p id="status" class="text-xl font-semibold mb-4 text-gray-700"></p>

        <div class="player-info">
            <div id="player-1-card" class="player-card active">
                <h3 class="text-lg font-bold">White</h3>
                <p>1s: <span id="p1-1s">4</span> | 2s: <span id="p1-2s">4</span> | 3s: <span id="p1-3s">4</span></p>
                <p>Score: <span id="p1-score">0</span></p>
            </div>
            <div id="player-2-card" class="player-card">
                <h3 class="text-lg font-bold">Black</h3>
                <p>1s: <span id="p2-1s">4</span> | 2s: <span id="p2-2s">4</span> | 3s: <span id="p2-3s">4</span></p>
                <p>Score: <span id="p2-score">0</span></p>
            </div>
        </div>

        <div class="number-selector">
            <button class="number-btn" data-value="1">1</button>
            <button class="number-btn" data-value="2">2</button>
            <button class="number-btn" data-value="3">3</button>
        </div>

        <div id="game-grid" class="game-grid"></div>
        
        <div id="message-box" class="hidden"></div>
        
        <div class="flex justify-center gap-4 mt-4">
            <button id="undo-btn">Undo</button>
            <div id="total-score-card" class="player-card">
                <h3 class="text-lg font-bold">Total Score</h3>
                <p id="total-score">0</p>
            </div>
        </div>
    </div>

    <script>
        // Game state variables
        let currentPlayer = 1;
        let selectedNumber = null;
        let board = Array(25).fill(null);
        const gridSize = 5;
        const centerIndex = Math.floor(board.length / 2);
        let history = []; // Stores past game states for undo
        let players = {
            1: {
                numbers: { '1': 4, '2': 4, '3': 4 },
                score: 0
            },
            2: {
                numbers: { '1': 4, '2': 4, '3': 4 },
                score: 0
            }
        };
        const playerNames = { 1: 'White', 2: 'Black' };

        // DOM elements
        const statusEl = document.getElementById('status');
        const gridEl = document.getElementById('game-grid');
        const numberButtons = document.querySelectorAll('.number-btn');
        const undoBtn = document.getElementById('undo-btn');
        const player1Card = document.getElementById('player-1-card');
        const player2Card = document.getElementById('player-2-card');
        const messageBox = document.getElementById('message-box');

        // Initial rendering on page load
        window.onload = function() {
            renderGrid();
            updateUI();

            // Event Listeners
            numberButtons.forEach(button => {
                button.addEventListener('click', () => selectNumber(button.dataset.value));
            });
            undoBtn.addEventListener('click', undo);
        };

        // Functions
        function renderGrid() {
            gridEl.innerHTML = '';
            for (let i = 0; i < 25; i++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.index = i;
                
                const contentDiv = document.createElement('div');
                contentDiv.classList.add('grid-cell-content');
                cell.appendChild(contentDiv);
                
                if (i === centerIndex) {
                    cell.classList.add('center-cell');
                    contentDiv.textContent = 'ko';
                    contentDiv.style.fontSize = '1.5rem';
                    contentDiv.style.color = '#a0aec0';
                } else if (board[i] !== null) {
                    cell.classList.add('occupied', `player-${board[i].player}`);
                    contentDiv.textContent = board[i].value;
                } else {
                    cell.addEventListener('click', handleCellClick);
                }
                gridEl.appendChild(cell);
            }
        }

        function updateUI() {
            statusEl.textContent = `${playerNames[currentPlayer]}'s turn`;
            document.getElementById(`p1-1s`).textContent = players[1].numbers['1'];
            document.getElementById(`p1-2s`).textContent = players[1].numbers['2'];
            document.getElementById(`p1-3s`).textContent = players[1].numbers['3'];
            document.getElementById(`p2-1s`).textContent = players[2].numbers['1'];
            document.getElementById(`p2-2s`).textContent = players[2].numbers['2'];
            document.getElementById(`p2-3s`).textContent = players[2].numbers['3'];
            document.getElementById(`p1-score`).textContent = players[1].score;
            document.getElementById(`p2-score`).textContent = players[2].score;
            document.getElementById('total-score').textContent = players[1].score + players[2].score;

            if (currentPlayer === 1) {
                player1Card.classList.add('active');
                player2Card.classList.remove('active');
            } else {
                player2Card.classList.add('active');
                player1Card.classList.remove('active');
            }

            numberButtons.forEach(btn => {
                const num = btn.dataset.value;
                btn.disabled = players[currentPlayer].numbers[num] === 0;
                btn.classList.remove('selected');
                if (num === selectedNumber) {
                    btn.classList.add('selected');
                }
            });
        }

        function selectNumber(value) {
            selectedNumber = value;
            updateUI();
        }

        function calculateScores() {
            // Reset scores
            players[1].score = 0;
            players[2].score = 0;

            for (let i = 0; i < 25; i++) {
                const cell = board[i];
                if (cell !== null) {
                    const row = Math.floor(i / gridSize);
                    const col = i % gridSize;
                    let tileScore = 0;

                    const neighbors = [
                        { r: row - 1, c: col }, // top
                        { r: row + 1, c: col }, // bottom
                        { r: row, c: col - 1 }, // left
                        { r: row, c: col + 1 }  // right
                    ];

                    neighbors.forEach(neighbor => {
                        if (neighbor.r >= 0 && neighbor.r < gridSize && neighbor.c >= 0 && neighbor.c < gridSize) {
                            const neighborIndex = neighbor.r * gridSize + neighbor.c;
                            const neighborValue = board[neighborIndex] ? board[neighborIndex].value : 0;
                            tileScore += Math.max(0, cell.value - neighborValue);
                        } else {
                            // Neighbor is outside the grid, treat as 0
                            tileScore += Math.max(0, cell.value - 0);
                        }
                    });

                    players[cell.player].score += tileScore;
                }
            }
        }

        function handleCellClick(event) {
            // Find the closest parent with the 'grid-cell' class to ensure we get the right element
            const cell = event.target.closest('.grid-cell');
            if (!cell) return; // Exit if the click was not on a valid cell

            const cellIndex = cell.dataset.index;
            if (cellIndex == centerIndex) {
                return;
            }

            if (selectedNumber === null) {
                showMessage("Please select a number first.");
                return;
            }

            if (board[cellIndex] === null) {
                // Save current state to history
                history.push({ 
                    board: [...board], 
                    players: JSON.parse(JSON.stringify(players)), 
                    currentPlayer: currentPlayer 
                });

                // Place the number
                board[cellIndex] = { value: parseInt(selectedNumber), player: currentPlayer };
                players[currentPlayer].numbers[selectedNumber]--;

                // Recalculate scores for both players
                calculateScores();

                // Switch player
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                selectedNumber = null;
                
                // Re-render and update UI
                renderGrid();
                updateUI();
                checkGameOver();
            }
        }

        function undo() {
            if (history.length > 0) {
                const lastState = history.pop();
                board = lastState.board;
                players = lastState.players;
                currentPlayer = lastState.currentPlayer;
                selectedNumber = null;
                renderGrid();
                updateUI();
                showMessage("Move undone.");
            } else {
                showMessage("Cannot undo further.");
            }
        }

        function checkGameOver() {
            const occupiedCells = board.filter(cell => cell !== null).length;
            if (occupiedCells === 24) {
                const p1Score = players[1].score;
                const p2Score = players[2].score;
                let winnerMessage = "";
                if (p1Score > p2Score) {
                    winnerMessage = `Game Over! White wins with a score of ${p1Score}!`;
                } else if (p2Score > p1Score) {
                    winnerMessage = `Game Over! Black wins with a score of ${p2Score}!`;
                } else {
                    winnerMessage = `Game Over! It's a tie with a score of ${p1Score}!`;
                }
                showMessage(winnerMessage);
            }
        }
        
        function showMessage(text) {
            messageBox.textContent = text;
            messageBox.classList.remove('hidden');
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 3000);
        }
    </script>
</body>
</html>
